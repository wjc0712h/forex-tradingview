// @version=6
indicator(title = "Heikin Ashi", shorttitle = "HA", overlay=true, max_labels_count=500)

// === INPUTS: HEIKIN ASHI ===
ha_timeframe_input = input.timeframe("1", title="HA Timeframe (Lower)")
hf_timeframe_input = input.timeframe("10", title="HA Timeframe (Higher)")
ha_ticker_id = ticker.heikinashi(syminfo.tickerid)

// Request Heikin Ashi OHLC for current timeframe (lower)
ha_open_series  = request.security(ha_ticker_id, ha_timeframe_input, open, lookahead=barmerge.lookahead_off)
ha_close_series = request.security(ha_ticker_id, ha_timeframe_input, close, lookahead=barmerge.lookahead_off)
ha_high_series  = request.security(ha_ticker_id, ha_timeframe_input, high, lookahead=barmerge.lookahead_off)
ha_low_series   = request.security(ha_ticker_id, ha_timeframe_input, low, lookahead=barmerge.lookahead_off)

// Request Heikin Ashi OHLC for higher timeframe
hf_ha_open_series  = request.security(ha_ticker_id, hf_timeframe_input, open, lookahead=barmerge.lookahead_off)
hf_ha_close_series = request.security(ha_ticker_id, hf_timeframe_input, close, lookahead=barmerge.lookahead_off)
hf_ha_high_series  = request.security(ha_ticker_id, hf_timeframe_input, high, lookahead=barmerge.lookahead_off)
hf_ha_low_series   = request.security(ha_ticker_id, hf_timeframe_input, low, lookahead=barmerge.lookahead_off)


// === TREND DETECTION FUNCTIONS ===

// Inputs for strong candle definition
// big_body_min = input.float(0, title="Big Body Min(0.0~1.0)", minval=0.0, maxval=1.0, step=0.05)
// wick_max_ratio = input.float(0, title="wick", minval=0.0, maxval=1.0, step=0.05)
// strong_candle_avg_multiplier = input.float(1.5, title="Strong Candle Avg Body Multiplier", minval=1.0, maxval=5.0, step=0.1)
// lookback_period = input.int(150, title="Lookback Period for Avg HA Body", minval=1)

// f_is_strong_ha_candle(ha_open_s, ha_close_s, ha_high_s, ha_low_s, index, body_min_ratio,wick_max_ratio) =>
//     prev_open = ha_open_s[index]
//     prev_close = ha_close_s[index]
//     prev_high = ha_high_s[index]
//     prev_low = ha_low_s[index]

//     prev_body_size = math.abs(prev_close - prev_open)
//     prev_total_range = prev_high - prev_low
//     is_large_body_relative = prev_body_size / prev_total_range >= body_min_ratio
//     total_body_size_sum = 0.0
//     for i = 1 to lookback_period
//         hist_open = ha_open_s[index + i] 
//         hist_close = ha_close_s[index + i]
//         total_body_size_sum += math.abs(hist_close - hist_open)
    
//     average_body_size = total_body_size_sum / lookback_period

//     is_body_actually_long = prev_body_size >= (average_body_size * strong_candle_avg_multiplier)

//     is_strong = false
//     if prev_close > prev_open // Bullish candle
//         // Original logic was commented out, I'm adding it back as an option for completeness if you need wick checks later
//         lower_wick_size = prev_open - prev_low
//         is_small_lower_wick = lower_wick_size / prev_total_range <= wick_max_ratio 
//         is_strong := is_large_body_relative and is_body_actually_long and is_small_lower_wick // Example with wick
        
//         //is_strong := is_large_body_relative and is_body_actually_long // Simplified as per your current code's emphasis
//     else if prev_close < prev_open // Bearish candle
//         // Original logic was commented out
//         upper_wick_size = prev_high - prev_open
//         is_small_upper_wick = upper_wick_size / prev_total_range <= wick_max_ratio
//         is_strong := is_large_body_relative and is_body_actually_long and is_small_upper_wick // Example with wick
        
//         //is_strong := is_large_body_relative and is_body_actually_long // Simplified
            
//     is_strong
f_detect_color_reversal(ha_open_s, ha_close_s) =>
    // Bullish reversal: Current candle is bullish, previous 2-3 were bearish
    bull_reversal = ha_close_s > ha_open_s and ha_close_s[1] < ha_open_s[1] and ha_close_s[2] < ha_open_s[2] 
    // Bearish reversal: Current candle is bearish, previous 2-3 were bullish
    bear_reversal = ha_close_s < ha_open_s and ha_close_s[1] > ha_open_s[1] and ha_close_s[2] > ha_open_s[2]  
    [bull_reversal, bear_reversal]

f_detect_trend(ha_open_s, ha_close_s) =>
    // Ensure all 3 previous candles are bullish/bearish
    bull_trend = ha_close_s[1] > ha_open_s[1]  
    bear_trend = ha_close_s[1] < ha_open_s[1] 
    [bull_trend, bear_trend]
f_detect_trend2(ha_open_s, ha_close_s) =>
    // Ensure all 3 previous candles are bullish/bearish
    bull_trend = ha_close_s[1] > ha_open_s[1] and ha_close_s[2] > ha_open_s[2] and ha_close_s[2] > ha_open_s[2] 
    bear_trend = ha_close_s[1] < ha_open_s[1] and ha_close_s[2] < ha_open_s[2]  and ha_close_s[2] < ha_open_s[2] 
    [bull_trend, bear_trend]

// === EXECUTE TREND AND REVERSAL DETECTION ===
[hf_bull_trend, hf_bear_trend] = f_detect_trend(hf_ha_open_series, hf_ha_close_series)
[bull_trend, bear_trend] = f_detect_trend2(ha_open_series, ha_close_series)

// === HA Signal Combinations ===
ha_buy_signal = hf_bull_trend and bear_trend
ha_sell_signal = hf_bear_trend and bull_trend

// === VWAP ===
anchor = input.string("Session", title="Anchor Period", options=["Session", "Week", "Month", "Quarter", "Year"], group="VWAP Settings")
src_ = input(title = "Source", defval = hlc3, group="VWAP Settings", display = display.data_window)
offset = input.int(0, title="Offset", group="VWAP Settings", minval=0)

BANDS_GROUP = "Bands Settings"
CALC_MODE_TOOLTIP = "Determines the units used to calculate the distance of the bands. When 'Percentage' is selected, a multiplier of 1 means 1%."
calcModeInput = input.string("Standard Deviation", "Bands Calculation Mode", options = ["Standard Deviation", "Percentage"], group = BANDS_GROUP, tooltip = CALC_MODE_TOOLTIP, display = display.data_window)
showBand_1 = input(false, title = "", group = BANDS_GROUP, inline = "band_1", display = display.data_window)
bandMult_1 = input.float(1.0, title = "Bands Multiplier #1", group = BANDS_GROUP, inline = "band_1", step = 0.5, minval=0, display = display.data_window)
showBand_2 = input(false, title = "", group = BANDS_GROUP, inline = "band_2", display = display.data_window)
bandMult_2 = input.float(2.0, title = "Bands Multiplier #2", group = BANDS_GROUP, inline = "band_2", step = 0.5, minval=0, display = display.data_window)
showBand_3 = input(false, title = "", group = BANDS_GROUP, inline = "band_3", display = display.data_window)
bandMult_3 = input.float(3.0, title = "Bands Multiplier #3", group = BANDS_GROUP, inline = "band_3", step = 0.5, minval=0, display = display.data_window)

cumVolume = ta.cum(volume)
isNewPeriod = switch anchor
    "Session" => timeframe.change("D")
    "Week"    => timeframe.change("W")
    "Month"   => timeframe.change("M")
    "Quarter" => timeframe.change("3M")
    "Year"    => timeframe.change("12M")
    => false

isEsdAnchor = anchor == "Earnings" or anchor == "Dividends" or anchor == "Splits"
if na(src_[1]) and not isEsdAnchor
	isNewPeriod := true

float vwapValue = na
float upperBandValue1 = na
float lowerBandValue1 = na
float upperBandValue2 = na
float lowerBandValue2 = na
float upperBandValue3 = na
float lowerBandValue3 = na

if not (timeframe.isdwm)
    [_vwap, _stdevUpper, _] = ta.vwap(src_, isNewPeriod, 1)
	vwapValue := _vwap
    stdevAbs = _stdevUpper - _vwap
	bandBasis = calcModeInput == "Standard Deviation" ? stdevAbs : _vwap * 0.01
	upperBandValue1 := _vwap + bandBasis * bandMult_1
	lowerBandValue1 := _vwap - bandBasis * bandMult_1
	upperBandValue2 := _vwap + bandBasis * bandMult_2
	lowerBandValue2 := _vwap - bandBasis * bandMult_2
	upperBandValue3 := _vwap + bandBasis * bandMult_3
	lowerBandValue3 := _vwap - bandBasis * bandMult_3

plot(vwapValue, title = "VWAP", color = #2962FF, offset = offset, display = display.none)

upperBand_1 = plot(upperBandValue1, title="Upper Band #1", color = color.green, offset = offset, display = showBand_1 ? display.all : display.none, editable = showBand_1)
lowerBand_1 = plot(lowerBandValue1, title="Lower Band #1", color = color.green, offset = offset, display = showBand_1 ? display.all : display.none, editable = showBand_1)
fill(upperBand_1, lowerBand_1,      title="Bands Fill #1", color = color.new(color.green, 95),   display = showBand_1 ? display.all : display.none, editable = showBand_1)

upperBand_2 = plot(upperBandValue2, title="Upper Band #2", color = color.olive, offset = offset, display = showBand_2 ? display.all : display.none, editable = showBand_2)
lowerBand_2 = plot(lowerBandValue2, title="Lower Band #2", color = color.olive, offset = offset, display = showBand_2 ? display.all : display.none, editable = showBand_2)
fill(upperBand_2, lowerBand_2,      title="Bands Fill #2", color = color.new(color.olive, 95),   display = showBand_2 ? display.all : display.none, editable = showBand_2)

upperBand_3 = plot(upperBandValue3, title="Upper Band #3", color = color.teal, offset = offset, display = showBand_3 ? display.all : display.none, editable = showBand_3)
lowerBand_3 = plot(lowerBandValue3, title="Lower Band #3", color = color.teal, offset = offset, display = showBand_3 ? display.all : display.none, editable = showBand_3)
fill(upperBand_3, lowerBand_3,      title="Bands Fill #3", color = color.new(color.teal, 95),   display = showBand_3 ? display.all : display.none, editable = showBand_3)
// === New VWAP Levels: Open, High, Low VWAPs ===
openVwap = ta.vwap(open, isNewPeriod)
highVwap = ta.vwap(high, isNewPeriod)
lowVwap = ta.vwap(low, isNewPeriod)

plot(openVwap, title="Open VWAP", color=color.purple, style=plot.style_line, linewidth=1, display=display.none)
plot(highVwap, title="High VWAP", color=color.orange, style=plot.style_line, linewidth=1, display=display.none)
plot(lowVwap, title="Low VWAP", color=color.blue, style=plot.style_line, linewidth=1, display=display.none)

tolerance_percent = input.float(0.01, title="Tolerance (%)", minval=0.0, maxval=1.0, step=0.001)
tolerance = close * tolerance_percent / 100
thrust_min_ratio = input.float(1.5, title="Thrust Candle Body Multiplier", minval=1.0, step=0.1)

f_touches_buy(band_, tolerance) => (band_ <= close) and (close <= band_ + tolerance)
f_touches_sell(band_, tolerance) => (band_ - tolerance <= close) and (close <= band_)

f_touches_buy2(band_) => open < band_ and close > band_
f_touches_sell2(band_) => open > band_ and close < band_

f_is_thrust_candle() =>
    body_size = math.abs(close - open)
    avg_body_size = ta.sma(math.abs(close - open), 10)
    is_thrust = body_size >= avg_body_size * thrust_min_ratio
    is_thrust

// Function to confirm bounce (price sustains move for at least one more bar)
f_confirm_bounce_buy() => close[1] > close[2] and close > close[1]  // Price continues upward
f_confirm_bounce_sell() => close[1] < close[2] and close < close[1]  // Price continues downward

lowest = close == ta.lowest(close, 3)
highest = close == ta.highest(close, 3)
// vwap_buy_zone = f_touches_buy(vwapValue,tolerance)  or f_touches_buy(lowerBandValue1,tolerance) or  f_touches_buy(lowerBandValue2,tolerance) or  f_touches_buy(lowerBandValue3,tolerance)  or (close < lowerBandValue3 and lowest)
// vwap_sell_zone = f_touches_sell(vwapValue,tolerance) or f_touches_sell(upperBandValue1,tolerance) or  f_touches_sell(upperBandValue2,tolerance) or  f_touches_sell(upperBandValue3,tolerance)or  (close > upperBandValue3 and highest)

vwap_buy_zone = f_touches_buy2(vwapValue)  or f_touches_buy2(lowerBandValue1) or f_touches_buy2(lowerBandValue2) or  f_touches_buy2(lowerBandValue3) or (close < lowerBandValue3 and lowest)
vwap_sell_zone = f_touches_sell2(vwapValue) or f_touches_sell2(upperBandValue1) or f_touches_sell2(upperBandValue2) or  f_touches_sell2(upperBandValue3) or  (close > upperBandValue3 and highest)

// // VWAP Buy Zone: Price near VWAP or lower bands (tolerance-based) or crossover
// vwap_buy_zone = (f_touches_buy(vwapValue, tolerance) or f_touches_buy(lowerBandValue1, tolerance) or f_touches_buy(lowerBandValue2, tolerance) or f_touches_buy(lowerBandValue3, tolerance) or f_touches_buy2(vwapValue) or f_touches_buy2(lowerBandValue1) or f_touches_buy2(lowerBandValue2) or f_touches_buy2(lowerBandValue3)) and f_is_thrust_candle() and f_confirm_bounce_buy()

// // VWAP Sell Zone: Price near VWAP or upper bands (tolerance-based) or crossover
// vwap_sell_zone = (f_touches_sell(vwapValue, tolerance) or f_touches_sell(upperBandValue1, tolerance) or f_touches_sell(upperBandValue2, tolerance) or f_touches_sell(upperBandValue3, tolerance) or f_touches_sell2(vwapValue) or f_touches_sell2(upperBandValue1) or f_touches_sell2(upperBandValue2) or f_touches_sell2(upperBandValue3)) and f_is_thrust_candle() and f_confirm_bounce_sell()
buy_signal = vwap_buy_zone and ha_buy_signal
sell_signal = vwap_sell_zone and ha_sell_signal

plotshape(buy_signal, title="Buy Entry", style=shape.circle, location=location.belowbar, color=color.rgb(76, 0, 255,66), size=size.tiny)
plotshape(sell_signal, title="Sell Entry", style=shape.circle, location=location.abovebar, color=color.rgb(76, 0, 255,66), size=size.tiny)

// === ALERTS ===
alertcondition(buy_signal or sell_signal, title="HA Signal", message="HA signal")
alertcondition(buy_signal, title="HA Buy Signal", message="HA BUY signal")
alertcondition(sell_signal, title="HA Sell Signal", message="HA SELL signal")